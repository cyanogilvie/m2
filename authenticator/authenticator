#!/usr/bin/env cfkit8.6
# vim: ft=tcl foldmarker=<<<,>>> foldmethod=marker ts=4 shiftwidth=4

proc mungekey {args} {}
#proc mungekey {key} {
#	set build	0
#	binary scan $key c* bytes
#	foreach byte $bytes {
#		incr build	$byte
#	}
#	return [format "%i" $build] 
#}

package require cflib
namespace eval cflib {
	namespace export *
}
namespace import cflib::*
cd [file dirname [info script]]

set iswrapped	[expr {[lindex [file system [info script]] 0] ne "native"}]
if {$iswrapped} {
	set base [file normalize [file join [file dirname [info script]] .. .. ..]]
} else {
	set base [file normalize [file dirname [info script]]]
}

set hold	[pwd]
cd $base
cflib::config create cfg $argv {
	variable uri				"tcp://localhost:5300"
	variable prkey				"/etc/codeforge/authenticator/keys/env/authenticator.pr"
	variable svc				"authenticator"
	variable svc_keys			"/etc/codeforge/authenticator/svc_keys"
	variable as_user			"codeforge"
	variable as_group			"codeforge"
	variable crypto_devmode		0
	variable plugin_dir			"/etc/codeforge/authenticator/plugins"
	variable cookie_shelflife	20000
	variable heartbeat_interval	120
	switch -- $::tcl_platform(platform) {
		"unix"	{variable db	"/var/lib/codeforge/authenticator/authenticator.sqlite3"}
		default	{variable db	"authenticator.sqlite3"}
	}
	variable daemon				1
}
cd $hold

proc log {lvl msg args} { #<<<
	puts stderr $msg
}

#>>>

if {[::tcl::pkgconfig get threaded]} {
	puts stderr "Cannot daemonize in a threaded interpreter"
	exit 1
}

package require sqlite3
package require cflib
package require sop
package require daemon 0.6
package require m2

source "crypto.tcl"
source "users.tcl"

source "userchans.tcl"
source "user.tcl"
source "userkeys.tcl"
source "svckeys.tcl"
source "plugins.tcl"
source "admin.tcl"

proc init {} { #<<<
	set ::online	[dict create]
	set ::userchans	[dict create]

	interp bgerror {} [list apply {
		{errmsg options} {
			log error [dict get $options -errorinfo]
		}
	}]

	m2::api2 create m2 -uri [cfg get uri]
	set loghandler	{
		log $lvl $msg {*}$args
	}
	oo::objdefine m2 method log {lvl {msg ""} args} $loghandler

	# Init db <<<
	sqlite3 db [cfg get db]
	if {[db onecolumn {
		select
			count(1) < 1	
		from
			sqlite_master
		where
			type = 'table'
			and name = 'delegations'
	}]} {
		db eval {
			create table delegations (
				domain_match	text primary key,
				plugin_name		text not null,
				plugin_params	text
			);
		}
	}
	# Init db >>>

	package require crypto

	Crypto create crypto
	Users create users
	Userkeys create userkeys
	Svckeys create svckeys
	Plugins create plugins
	Admin create admin

	oo::objdefine crypto method log {lvl {msg ""} args} $loghandler
	oo::objdefine users method log {lvl {msg ""} args} $loghandler
	oo::objdefine userkeys method log {lvl {msg ""} args} $loghandler
	oo::objdefine svckeys method log {lvl {msg ""} args} $loghandler
	oo::objdefine plugins method log {lvl {msg ""} args} $loghandler
	oo::objdefine admin method log {lvl {msg ""} args} $loghandler

	[m2 signal_ref connected] attach_output [list apply {
		{newstate} {
			log LOG_INFO "m2 connection state: [expr {$newstate ? "connected" : "not connected"}]"
			if {$newstate} {
				log LOG_INFO "Advertising service \"[cfg get svc]\""
				m2 handle_svc [cfg get svc] [list apply {
					{seq data} {
						set rest	[lassign $data op]

						switch -- $op {
							"crypt_setup" {
								crypto crypt_setup $seq $rest
							}

							default {
								log LOG_ERR "Unhandled request type: ($op)"
							}
						}
					}
				}]
			} else {
				#log LOG_INFO "Revoking service \"[cfg get svc]\""
				#m2 handle_svc [cfg get svc] ""
			}
		}
	}]
}

#>>>
proc cleanup {} { #<<<
}

#>>>

if {[cfg get daemon]} {
	dutils::daemon create daemon \
			-name 			"authenticatord" \
			-as_user		[cfg get as_user] \
			-as_group		[cfg get as_group] \
			-gen_pid_file	{return "/var/tmp/authenticator.pid"}

	proc log {lvl msg args} { #<<<
		daemon log $lvl $msg {*}$args
	}

	#>>>

	set cmd		[lindex [cfg rest] 0]
	if {$cmd eq ""} {
		set cmd		"start"
	}

	daemon apply_cmd $cmd

	daemon cleanup {
		cleanup
	}

	daemon fork {
		dutils::umask 022
		init
	}
} else {
	init
	coroutine coro_main vwait forever
}

